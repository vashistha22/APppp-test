# -*- coding: utf-8 -*-
"""Untitled15.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14swpeSLg957S6P2gmrNfgcBYj4xO9yNk
"""

!pip -q install ta yfinance xgboost plotly scikit-learn PyPortfolioOpt

# Import Libraries
import warnings, numpy as np, pandas as pd
warnings.filterwarnings("ignore")

import yfinance as yf
import ta  # technical indicators (stable alternative to pandas_ta)
import xgboost as xgb
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score, roc_auc_score, classification_report

import plotly.express as px
from pypfopt.expected_returns import mean_historical_return
from pypfopt.risk_models import CovarianceShrinkage
from pypfopt.efficient_frontier import EfficientFrontier, EfficientCVaR
from pypfopt.discrete_allocation import DiscreteAllocation, get_latest_prices

np.random.seed(42)

# Settings
TICKERS = ["AAPL", "MSFT", "GOOG", "AMZN", "META"]   # change as you like
START   = "2014-01-01"
END     = "2025-01-01"
PORTFOLIO_VALUE = 100_000

# Download adjusted close prices
prices = yf.download(TICKERS, start=START, end=END, auto_adjust=True)["Close"]
prices = prices.dropna(how="all")
returns = prices.pct_change().dropna()

print(f"\nData shape: prices={prices.shape}, returns={returns.shape}")

# Build features with `ta` per ticker
def make_features(series_close: pd.Series) -> pd.DataFrame:
    """Return a DataFrame with indicators built from a close-price series."""
    df = pd.DataFrame({"Close": series_close})
    # RSI
    df["RSI"] = ta.momentum.RSIIndicator(close=df["Close"], window=14).rsi()
    # MACD
    macd = ta.trend.MACD(close=df["Close"])
    df["MACD"] = macd.macd()
    # Bollinger Bands
    bb = ta.volatility.BollingerBands(close=df["Close"], window=20, window_dev=2)
    df["BB_high"] = bb.bollinger_hband()
    df["BB_low"]  = bb.bollinger_lband()
    # Volatility (rolling stdev of daily returns)
    df["Volatility"] = df["Close"].pct_change().rolling(21).std()
    # Label: next-day return (for direction)
    df["NextRet"] = df["Close"].pct_change().shift(-1)
    return df

feat_list = []
for t in TICKERS:
    f = make_features(prices[t].dropna())
    f["Ticker"] = t
    feat_list.append(f)

features = pd.concat(feat_list, axis=0)
features = features.dropna().copy()

# Classification label: 1 if next-day return > 0 else 0
features["Up"] = (features["NextRet"] > 0).astype(int)

X = features[["RSI", "MACD", "BB_high", "BB_low", "Volatility"]]
y = features["Up"]

# Chronological split to avoid leakage
split_idx = int(len(features) * 0.8)
X_train, X_test = X.iloc[:split_idx], X.iloc[split_idx:]
y_train, y_test = y.iloc[:split_idx], y.iloc[split_idx:]

# Train XGBoost next-day direction model
clf = xgb.XGBClassifier(
    n_estimators=400,
    max_depth=5,
    learning_rate=0.05,
    subsample=0.9,
    colsample_bytree=0.9,
    eval_metric="logloss",
    tree_method="hist"
)
clf.fit(X_train, y_train)

pred_test = clf.predict(X_test)
proba_test = clf.predict_proba(X_test)[:, 1]
acc  = accuracy_score(y_test, pred_test)
auc  = roc_auc_score(y_test, proba_test)

print(f"\nXGBoost next-day direction â€” Accuracy: {acc:.3f}, ROC-AUC: {auc:.3f}")
print(classification_report(y_test, pred_test, digits=3))

# Latest per-ticker ML signal (today's prob of going up)

# Take the last available feature row for each ticker
last_feats = (
    features.groupby("Ticker")
            .tail(1)
            .set_index("Ticker")
)

last_X = last_feats[["RSI", "MACD", "BB_high", "BB_low", "Volatility"]]
last_feats["ProbUp"] = clf.predict_proba(last_X)[:, 1]
ml_signal = last_feats["ProbUp"].sort_values(ascending=False)
print("\nLatest ML signal (Prob of Up by ticker):")
print(ml_signal)

# Visualize signal
fig = px.bar(ml_signal, title="Latest ML probability of positive return (per ticker)")
fig.update_layout(yaxis_title="Prob(Up)")
fig.show()

# Portfolio Optimization

mu_all = mean_historical_return(prices)                       # expected returns
S_all  = CovarianceShrinkage(prices).ledoit_wolf()            # robust covariance

# (A) Max Sharpe on all tickers
ef = EfficientFrontier(mu_all, S_all)
w_sharpe = ef.max_sharpe()
w_sharpe = ef.clean_weights()
print("\nMax-Sharpe weights (all tickers):")
print(w_sharpe)

# (B) Min-CVaR on top-N by ML signal
TOP_N = min(5, len(TICKERS))
top_tickers = list(ml_signal.head(TOP_N).index)
ret_subset = returns[top_tickers].dropna()
mu_sub = mean_historical_return(prices[top_tickers])
ef_cvar = EfficientCVaR(mu_sub, ret_subset)
w_cvar = ef_cvar.min_cvar()
w_cvar = ef_cvar.clean_weights()
print(f"\nMin-CVaR weights (top {TOP_N} ML tickers {top_tickers}):")
print(w_cvar)

# Discrete allocation for both portfolios
latest_prices = get_latest_prices(prices)

da_sharpe = DiscreteAllocation(w_sharpe, latest_prices, total_portfolio_value=PORTFOLIO_VALUE)
alloc_sharpe, cash_left_sharpe = da_sharpe.lp_portfolio()

da_cvar = DiscreteAllocation(w_cvar, latest_prices, total_portfolio_value=PORTFOLIO_VALUE)
alloc_cvar, cash_left_cvar = da_cvar.lp_portfolio()

print("\nDiscrete allocation (Max-Sharpe):", alloc_sharpe, f" | Cash left: ${cash_left_sharpe:.2f}")
print(  "Discrete allocation (Min-CVaR): ", alloc_cvar,  f" | Cash left: ${cash_left_cvar:.2f}")

# Quick backtest comparison (equal-weight vs Max-Sharpe)

eq_w = np.repeat(1/len(TICKERS), len(TICKERS))
cum_eq  = (1 + (returns * eq_w).sum(axis=1)).cumprod()

w_vec   = pd.Series(w_sharpe).reindex(returns.columns).fillna(0).values
cum_opt = (1 + (returns * w_vec).sum(axis=1)).cumprod()

cum_df = pd.concat([cum_eq.rename("EqualWeight"), cum_opt.rename("MaxSharpe")], axis=1).dropna()
fig2 = px.line(cum_df, title="Cumulative Growth: Equal-Weight vs Max-Sharpe")
fig2.update_layout(yaxis_title="Growth of $1")
fig2.show()

# Streamlit dashboard

import streamlit as st
import pandas as pd
import plotly.express as px
import inspect

def dashboard(df):
    st.title("ðŸ“ˆ Stock Return Forecasting & Portfolio Optimization Dashboard")

    # Show raw data
    st.subheader("Raw Stock Data")
    st.dataframe(df.head())

    # Plot stock prices
    st.subheader("Stock Price Trend")
    fig = px.line(df, x=df.index, y="Close", title="Stock Closing Price Over Time")
    st.plotly_chart(fig, use_container_width=True)

    # Plot returns
    st.subheader("Daily Returns Distribution")
    df["Returns"] = df["Close"].pct_change()
    fig2 = px.histogram(df, x="Returns", nbins=50, title="Distribution of Daily Returns")
    st.plotly_chart(fig2, use_container_width=True)

    # Rolling volatility
    st.subheader("Rolling Volatility (30-day)")
    df["Volatility"] = df["Returns"].rolling(30).std()
    fig3 = px.line(df, x=df.index, y="Volatility", title="30-day Rolling Volatility")
    st.plotly_chart(fig3, use_container_width=True)

with open("app.py", "w") as f:
    f.write(inspect.getsource(dashboard))

print("\nâœ… Streamlit app saved to app.py")
print("To try locally:  !streamlit run app.py --server.enableCORS false --server.enableXsrfProtection false")

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# import streamlit as st
# import pandas as pd
# import yfinance as yf
# import plotly.express as px
# import ta
# 
# # Download stock data
# df = yf.download("AAPL", start="2020-01-01", end="2023-01-01")
# df["Returns"] = df["Close"].pct_change()
# df["RSI"] = ta.momentum.RSIIndicator(df["Close"], window=14).rsi()
# 
# # Streamlit Dashboard
# st.title("ðŸ“ˆ Stock Return Forecasting & Portfolio Optimization")
# 
# st.subheader("Raw Stock Data")
# st.dataframe(df.tail())
# 
# st.subheader("Stock Price Trend")
# fig = px.line(df, x=df.index, y="Close", title="Stock Closing Price")
# st.plotly_chart(fig, use_container_width=True)
# 
# st.subheader("RSI Trend")
# fig2 = px.line(df, x=df.index, y="RSI", title="Relative Strength Index (RSI)")
# st.plotly_chart(fig2, use_container_width=True)
# 
# st.subheader("Daily Returns Distribution")
# fig3 = px.histogram(df, x="Returns", nbins=50, title="Returns Distribution")
# st.plotly_chart(fig3, use_container_width=True)
#